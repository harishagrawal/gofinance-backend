// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=RandomEmail_1905439733
ROOST_METHOD_SIG_HASH=RandomEmail_7a04f189fd

Scenario 1: Generate valid random email for the number greater than zero

Details:
Description: This test checks if the function `RandomEmail` can generate a valid email which contains the requested number of random characters before the "@" sign.
Execution:
Arrange: No preparation needed.
Act: Invoke `RandomEmail` with a single positive number as a parameter.
Assert: Check if the result is valid and meets our expectations - contains "@" sign and random string length is exactly as specified in the parameter.
Validation:
The test is important because it checks the regular work of our function. We choose simple validation just to check if the number of characters before the "@" is the same as parameter.

Scenario 2: Generate valid random email for the zero number

Details:
Description: The test checks if the function `RandomEmail` can handle zero as a parameter and generate a valid email "random" string with zero characters before the "@".
Execution:
Arrange: No preparation needed.
Act: Invoke `RandomEmail` with zero as a parameter.
Assert: Check if the result is valid - it should contain nothing before "@".
Validation:
The test is important to check the edge case when the number parameter equals zero. It's important because it's a limit situation for our function.

Scenario 3: Generate valid random email for a very large number

Details:
Description: The test is designed to check if the function `RandomEmail` can handle a very large number as a parameter and generate a valid email "random" string of length equal to that big number.
Execution:
Arrange: No preparation needed.
Act: Invoke `RandomEmail` with a very large number as a parameter.
Assert: Check if the result is valid - it should contain a long string before "@".
Validation:
The test is important because it checks how our function behaves with extremely big inputs. This might be important due to memory constraints or for performance consideration.

Scenario 4: Generate valid random email for negative numbers

Details:
Description: The test checks if the function `RandomEmail` can handle negative numbers. It's unclear how this function will behave in such a case (it might reject such inputs or treat them as positive), so it's important to clarify this behavior.
Execution:
Arrange: No preparation needed.
Act: Invoke `RandomEmail` with a negative number as a parameter.
Assert: Check how the function behaves - does it return any valid value or does it cause a run-time error?
Validation:
The test is important because it's an edge case for our function. Handling negative values can be problematic and it's good to be sure how our function behaves in this situation.
*/

// ********RoostGPT********
package util

import (
	"testing"
	"strings"
)

func TestRandomEmail(t *testing.T) {
	//Setting up scenarios
	testCases := []struct {
		name     string
		number   int
		expected int
	}{
		{name: "Generate random email with positive length", number: 10, expected: 10},
		{name: "Generate random email with zero length", number: 0, expected: 0},
		{name: "Generate random email with large positive length", number: 1000, expected: 1000},
		{name: "Generate random email with negative length", number: -10, expected: 0},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			email := RandomEmail(tc.number)

			// Check if the string before "@" matches the expected length.
			parts := strings.Split(email, "@")
			got := len(parts[0])
			if got != tc.expected {
				t.Errorf("expected %v, got %v", tc.expected, got)
			}

			// Check if the result is a valid email address.
			if !strings.Contains(email, "@") {
				t.Errorf("expected an email address, got %s", email)
			}
		})
	}
}
