// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=RandomString_d7e3599ac4
ROOST_METHOD_SIG_HASH=RandomString_c6fe4ad19a

Scenario 1: Random String Generation Test
  Details:
    Description: This test is meant to check if the function RandomString generates a random string of specified length, covering the normal operation.
  Execution:
    Arrange: No need to set up any required data, mocks, or test doubles.
    Act: Invoke the RandomString function with a positive integer parameter.
    Assert: Use Go testing facilities to verify that the actual string length matches the length specified.
  Validation:
    The assertion logic is that assumed the function RandomString should return a string of length as specified by the input parameter. The importance of this test is to ensure the function implements the specified functionality correctly.

Scenario 2: Zero Length String Test 
  Details:
    Description: This test is meant to check if the function RandomString can handle edge cases, such as generating a random string of zero length.
  Execution:
    Arrange: No need to set up any required data, mocks, or test doubles.
    Act: Invoke the RandomString function with zero as a parameter.
    Assert: Use Go testing facilities to verify that the actual result is an empty string.
  Validation:
    The assertion logic is that assumed the function RandomString should return an empty string when called with zero as an argument. If the function can properly handle this edge case, it helps to prevent potential crashes or errors in production.

Scenario 3: Negative Length String Test 
  Details:
    Description: This test is meant to check how the function RandomString behaves with a negative integer as a parameter.
  Execution:
    Arrange: No need to set up any required data, mocks, or test doubles.
    Act: Invoke the RandomString function with a negative integer as a parameter.
    Assert: Use Go testing facilities to verify that the actual result is an empty string.
  Validation:
    The assertion logic is that assumed the function RandomString should return an empty string for negative input as it's an invalid case. This test is important as it verifies the function's response to invalid inputs, which could allow it to handle exceptions gracefully. 

Scenario 4: Random String Qualitative Test
  Details:
    Description: This test is aimed at validating the quality of the generated random string, ensuring it consists only of the characters present in the "alphabet".
  Execution:
    Arrange: Define a known value of "alphabet" to check against.
    Act: Call the RandomString function with a positive integer parameter and capture the output string.
    Assert: Check that every character in the generated string is present in the defined "alphabet".
  Validation:
    The assertion checks that the function is correctly selecting characters from the "alphabet" for the generated random string. This helps ensure the output string conforms to expected characteristics, validating the output quality.
*/

// ********RoostGPT********
// Import necessary packages
package util_test

import (
	"strings"
	"testing"
	"util"
)

// TestRandomString validates that the RandomString function operates as expected
func TestRandomString(t *testing.T) {
	/*** Add TODO wherever user modification is required ***/
	// Assume 'alphabet' variable from the util package is defined something like this
	// alphabet := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

	// Define test scenarios
	tests := []struct {
		name     string
		length   int
		expected int // expected is length of response string
		err      error
	}{
		{"Random String Generation Test", 5, 5, nil},
		{"Zero Length String Test", 0, 0, nil},
		{"Negative Length String Test", -1, 0, nil},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Call the RandomString function with provided length
			res := util.RandomString(tt.length)

			// Validate length of returned string
			if len(res) != tt.expected {
				t.Errorf("Expected string of length %d but got %d", tt.expected, len(res))
			}

			// Scenario 4 test, check string is composed of characters from alphabet
			for _, char := range res {
				if !strings.ContainsRune(util.alphabet, rune(char)) {
					t.Errorf("Random string contains an invalid character: %v", string(char))
				}
			}
			t.Log("Test Scenario Passed:", tt.name)
		})
	}
}
