// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Open AI and AI Model gpt-4-1106-preview

func RandomEmail(number int) string {
	return fmt.Sprintf("%s@email.com", RandomString(number))
}

Based on the code content for `random.go` file, we can begin formulating test scenarios for the `RandomEmail` function. We will create scenarios that test the function's regular operation, edge cases, and error handling.

Scenario 1: Generate a random email with a valid length
```
Details:
  TestName: TestRandomEmailWithValidLength
  Description: This test confirms that the RandomEmail function generates an email with a requested local part length.
Execution:
  Arrange: Define expected email pattern and length.
  Act: Call RandomEmail with a specified length.
  Assert: Use a regular expression to match the result against the expected email pattern ensuring the local part length is as requested.
Validation:
  Justify: We expect that when given a valid length, RandomEmail returns a string that matches the email format with that exact local part length.
  Importance: This test ensures the function behaves correctly under normal conditions and that the random email generator supports a range of email lengths.
```

Scenario 2: Generate a random email with zero length
```
Details:
  TestName: TestRandomEmailWithZeroLength
  Description: This test ensures that the RandomEmail function can handle a request for zero-length local part, effectively returning a predictable result.
Execution:
  Arrange: Specify a zero length for the email's local part.
  Act: Call RandomEmail with a length of 0.
  Assert: Validate that the returned email is exactly "email.com", which would be the expected outcome when no local part is provided.
Validation:
  Justify: The function should be able to handle edge cases, including when no local part is desired in the email. The expected result in this case is to only return the domain part.
  Importance: This test is essential to ensure that the function properly handles edge cases and does not fail or produce unexpected results when receiving a zero input value.
```

Scenario 3: Generate a random email with negative length
```
Details:
  TestName: TestRandomEmailWithNegativeLength
  Description: This test checks the RandomEmail function's behavior when called with a negative length which is an invalid value.
Execution:
  Arrange: Specify a negative length for the email's local part.
  Act: Call RandomEmail with a negative length value.
  Assert: Verify that the result is an empty string or possibly an error, depending on how the function should behave with invalid inputs. Alternatively, if the function has no explicit error handling, validate that the result still contains "@email.com" confirming that the domain part is unaffected.
Validation:
  Justify: The function's behavior might not be defined for negative values, so the test will be helpful to document the current behavior or identify if handling should be added.
  Importance: This test validates how the function deals with invalid inputs and if there is a need for additional error handling within the function.
```

Scenario 4: Generate random emails consistently with different lengths
```
Details:
  TestName: TestRandomEmailWithVariousLengths
  Description: This test ensures that multiple calls to RandomEmail with different lengths all produce valid emails of the correct lengths.
Execution:
  Arrange: Prepare a range of valid lengths and results storage.
  Act: Call RandomEmail with varying lengths and store results.
  Assert: Loop through stored results, applying a regular expression to each to validate that email is of the correct pattern and local part length.
Validation:
  Justify: To ensure the robustness of the random email generator, it is important to test that it can consistently generate emails of various lengths.
  Importance: This test is significant for ensuring that the function performs reliably across a range of expected conditions and that email generation is not biased towards any specific length.
```

These scenarios should provide good coverage for testing the `RandomEmail` function.
*/

// ********RoostGPT********
package util // Use the actual package name as per the file's content

import (
	"regexp"
	"testing"
)

// TestRandomEmailWithValidLength tests that RandomEmail generates an email with the requested local part length.
func TestRandomEmailWithValidLength(t *testing.T) {
	length := 10 // Example length for a valid email
	email := RandomEmail(length)
	pattern := `^\w{10}@\w+\.\w+$`
	matched, err := regexp.MatchString(pattern, email)
	if err != nil {
		t.Errorf("error matching regex: %v", err)
	}
	if !matched {
		t.Errorf("expected email to match pattern %s, got %s", pattern, email)
	}
}

// TestRandomEmailWithZeroLength tests that RandomEmail can handle a request for a zero-length local part.
func TestRandomEmailWithZeroLength(t *testing.T) {
	email := RandomEmail(0)
	expected := "email.com"
	if email != expected {
		t.Errorf("expected email to be %s, got %s", expected, email)
	}
}

// TestRandomEmailWithNegativeLength tests the RandomEmail function's behavior with a negative length.
func TestRandomEmailWithNegativeLength(t *testing.T) {
	email := RandomEmail(-1)
	expected := ""
	if email != expected {
		t.Errorf("expected email to be an empty string, got %s", email)
	}
}

// TestRandomEmailWithVariousLengths ensures that RandomEmail generates valid emails of various lengths.
func TestRandomEmailWithVariousLengths(t *testing.T) {
	lengths := []int{5, 10, 15} // Example lengths for valid emails
	for _, length := range lengths {
		email := RandomEmail(length)
		pattern := `^\w{` + string(length) + `}@\w+\.\w+$`
		matched, err := regexp.MatchString(pattern, email)
		if err != nil {
			t.Errorf("error matching regex for length %d: %v", length, err)
		}
		if !matched {
			t.Errorf("expected email of length %d to match pattern %s, got %s", length, pattern, email)
		}
	}
}

