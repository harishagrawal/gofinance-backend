// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Open AI and AI Model gpt-4-1106-preview

[
  {
    "vulnerability": "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)",
    "issue": "The RandomString function uses math/rand for generating pseudo-random strings, which is not cryptographically secure and can lead to the predictability of random values.",
    "solution": "Replace the math/rand package with the crypto/rand package to generate cryptographically secure random values."
  }
]

Based on the contents of the `random.go` file we extracted and read, we will now craft test scenarios for the function `RandomString`. Here are the scenarios:

---

Scenario 1: Verify length of generated string

Details:  
  TestName: TestRandomStringLength  
  Description: This test verifies that the RandomString function generates a string of the expected length.
Execution:  
  Arrange: Define a variable for the desired length of the string.
  Act: Call RandomString with the predefined length.
  Assert: Use the "Go's" `len` function to verify that the length of the generated string matches the desired length.
Validation:  
  Justify: Ensuring that the generated string is of the correct length is fundamental to the function's contract.
  Importance: The length of the string may be crucial for identifiers, session tokens, or other uses where a specific length is expected.

Scenario 2: Ensure no non-alphabetic characters

Details:  
  TestName: TestRandomStringContent  
  Description: This test checks that the RandomString function only contains alphabetic characters and no numerics or special characters.
Execution:  
  Arrange: Generate a string using the RandomString function.
  Act: Call RandomString to generate a string of a reasonable length.
  Assert: Use regular expressions to assert that the string only contains characters from a to z.
Validation:  
  Justify: The function is supposed to return a string containing only alphabet characters as per the constant `alphabet`.
  Importance: The purity of the string content is essential for maintaining consistencies in generated data such as tokens, which are often limited to specific character sets.

Scenario 3: Ensure randomness of generated strings

Details:  
  TestName: TestRandomStringRandomness  
  Description: This test checks that the RandomString function generates differently random strings over multiple invocations.
Execution:  
  Arrange: Generate two strings using the RandomString function with the same input length.
  Act: Call RandomString twice with the same length parameter.
  Assert: Assert that the two strings are not equal.
Validation:  
  Justify: Although it's statistically possible (but extremely unlikely) to generate the same string, this test checks for the general case where different invocations should yield different results.
  Importance: It's important for the function to generate unique strings for use cases such as generating unique user identifiers or session tokens.

Scenario 4: Edge case with a length of zero

Details:  
  TestName: TestRandomStringZeroLength  
  Description: This test checks the behavior of RandomString when passed a length of zero.
Execution:  
  Arrange: Define a length variable set to zero.
  Act: Call RandomString with the length variable.
  Assert: Assert that the generated string is empty.
Validation:  
  Justify: Passing a zero length should logically return an empty string as there are no characters to generate.
  Importance: This tests the function's behavior at boundary conditions which is crucial for robustness in edge cases.

Scenario 5: Negative length input

Details:  
  TestName: TestRandomStringNegativeLength  
  Description: This test checks how RandomString behaves when passed a negative length.
Execution:  
  Arrange: Define a length variable with a negative value.
  Act: Call RandomString with the negative length variable.
  Assert: The test scenario should expect a panic or error return, and this behavior should be asserted accordingly based on whether the function handles the negative input.
Validation:  
  Justify: This test determines the resilience of the function in the face of invalid input.
  Importance: Protecting the application from crashing due to unexpected input is a necessary part of defensive programming.

---

Keep in mind that the scenarios are based on the `RandomString` function without any observable error handling for negative input; therefore, we presume based on standard practice that a negative input would panic. However, if the function was implemented to handle such cases gracefully, then Scenario 5 would be adjusted accordingly.
*/

// ********RoostGPT********
package util // replace with the actual package name defined in random.go

import (
	"regexp"
	"testing"
)

func TestRandomStringLength(t *testing.T) {
	expectedLength := 10
	str := RandomString(expectedLength)
	if len(str) != expectedLength {
		t.Errorf("expected string of length %d, got string of length %d", expectedLength, len(str))
	}
}

func TestRandomStringContent(t *testing.T) {
	length := 10
	str := RandomString(length)
	if !regexp.MustCompile(`^[a-zA-Z]+$`).MatchString(str) {
		t.Errorf("expected string to contain only alphabetic characters, got: %s", str)
	}
}

func TestRandomStringRandomness(t *testing.T) {
	length := 10
	str1 := RandomString(length)
	str2 := RandomString(length)
	if str1 == str2 {
		t.Errorf("expected different strings, got identical strings: %s and %s", str1, str2)
	}
}

func TestRandomStringZeroLength(t *testing.T) {
	length := 0
	str := RandomString(length)
	if str != "" {
		t.Errorf("expected empty string, got: %s", str)
	}
}

func TestRandomStringNegativeLength(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("expected panic when providing a negative length")
		}
	}()
	negativeLength := -1
	RandomString(negativeLength) // this should panic
}

