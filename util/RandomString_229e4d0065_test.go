// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Open AI and AI Model gpt-4

1. Test if the function returns a string of the correct length as specified by the input parameter.
2. Test if the function returns a unique string each time it's called, since it's supposed to be random.
3. Test if the function returns an empty string when the input parameter is 0.
4. Test if the function returns a string only containing characters from the predefined alphabet.
5. Test if the function handles negative input parameters correctly, as it's not specified in the function definition.
6. Test if the function can handle large input parameters without crashing or significantly slowing down the system.
7. Test if the function is thread-safe when called from multiple threads concurrently.
8. Test if the function can be called multiple times in quick succession without any issues.
9. Test if the function handles maximum integer value without causing an overflow error.
10. Test if the function handles minimum integer value without causing an underflow error.
11. Test if the function is able to handle and return special characters if they are part of the alphabet.
*/

// ********RoostGPT********
package util

import (
	"math"
	"math/rand"
	"strings"
	"sync"
	"testing"
	"time"
)

// removed the redeclaration of alphabet

func TestRandomString_229e4d0065(t *testing.T) {
	testCases := []struct {
		name     string
		input    int
		expected int
	}{
		{"Test Length", 5, 5},
		{"Test Zero", 0, 0},
		{"Test Negative", -5, 0},
		{"Test Large", 1000, 1000},
		{"Test MaxInt", math.MaxInt32, math.MaxInt32},
		{"Test MinInt", math.MinInt32, 0},
	}

	rand.Seed(time.Now().UnixNano())

	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			got := RandomString(tt.input)
			if len(got) != tt.expected {
				t.Errorf("RandomString(%d) = %d; want %d", tt.input, len(got), tt.expected)
			}

			if !isStringAlpha(got) {
				t.Errorf("RandomString(%d) contains non-alphabet characters", tt.input)
			}
		})
	}

	t.Run("Test Uniqueness", func(t *testing.T) {
		s1 := RandomString(5)
		s2 := RandomString(5)
		if s1 == s2 {
			t.Error("RandomString(5) is not unique")
		}
	})

	t.Run("Test Concurrency", func(t *testing.T) {
		var wg sync.WaitGroup
		for i := 0; i < 10; i++ {
			wg.Add(1)
			go func() {
				defer wg.Done()
				RandomString(5)
			}()
		}
		wg.Wait()
	})

	t.Run("Test Quick Succession", func(t *testing.T) {
		for i := 0; i < 10; i++ {
			RandomString(5)
		}
	})
}

func isStringAlpha(s string) bool {
	for _, c := range s {
		if !strings.ContainsRune(string(alphabet), c) {
			return false
		}
	}
	return true
}
