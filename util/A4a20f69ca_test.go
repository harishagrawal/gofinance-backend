// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Open AI and AI Model gpt-4-1106-preview

[
  {
    "vulnerability": "Predictable Random Number Generator",
    "issue": "The rand.Seed call with time.Now().UnixNano() could result in a predictable random number generator if an attacker can guess the time of the seed's initialization. This reduces the overall randomness and could lead to security vulnerabilities if used for session tokens, cryptographic keys, or other security-sensitive features.",
    "solution": "Use a more secure random number generator provided by Golang's crypto/rand package for generating secure tokens or keys. Replace rand.Seed and rand.Intn calls with methods from crypto/rand when cryptographic security is required."
  },
  {
    "vulnerability": "Insufficient Entropy in Random String Generation",
    "issue": "The RandomString function in the RandomEmail method uses a limited character set of lowercase alphabetic characters, which reduces the entropy and makes the generated emails more susceptible to brute-force attacks.",
    "solution": "Expand the character set to include uppercase letters, digits, and special characters. Increase the length of the random string to add more complexity and entropy."
  },
  {
    "vulnerability": "Lack of Uniqueness Checks for Generated Emails",
    "issue": "Generated email addresses by RandomEmail are not guaranteed to be unique; if used as unique identifiers or account emails, it could result in collisions and overwrite data or provide an avenue for account takeover.",
    "solution": "Implement a mechanism to check for the uniqueness of generated email addresses against a database or store. If a collision is detected, either regenerate the email or append a unique identifier to ensure uniqueness."
  }
]

Based on the contents of the `random.go` file, we can see that the package name is `util` and the `RandomEmail` function generates an email string using a specified number of random characters followed by `@email.com`. The function doesn't check the number parameter for any constraints like being non-negative.

Given this information, let's draft meaningful test scenarios for the `RandomEmail` function.

---

Scenario 1: Test Email Generation with Valid Length

Details:
  TestName: TestRandomEmailValidLength
  Description: This test checks whether the RandomEmail function is able to generate a valid email with a correct number of random characters for a positive length value.
Execution:
  Arrange: Choose a positive integer value for the email length (excluding the domain "@email.com").
  Act: Call the RandomEmail function with the chosen positive integer.
  Assert: Verify that the returned email string is of the correct length and follows the pattern "[random_characters]@email.com".
Validation:
  Justify: The email length should match the number of requested random characters plus the constant length of the domain. This confirms the correctness of the generated email.
  Importance: Ensuring RandomEmail correctly handles valid lengths is crucial for generating emails of different lengths as needed throughout the application.

---

Scenario 2: Test Email Generation with Zero Length

Details:
  TestName: TestRandomEmailZeroLength
  Description: This test ensures that the RandomEmail function can handle a length of zero and returns an email consisting only of the domain part.
Execution:
  Arrange: Set the length parameter to zero.
  Act: Call the RandomEmail function with a length of zero.
  Assert: Check that the resulting email is just the domain part "@email.com" with no random characters preceding it.
Validation:
  Justify: A zero length should result in no random characters being generated, leaving only the domain. This ensures the function does not produce an unintended prefix.
  Importance: This test confirms that the function behaves correctly even when no random characters are expected, which may be a valid use case in certain contexts or an edge case to handle gracefully.

---

Scenario 3: Test Email Generation with Negative Length

Details:
  TestName: TestRandomEmailNegativeLength
  Description: This test scenario verifies the behaviour of RandomEmail when passed a negative length and whether it handles the input gracefully.
Execution:
  Arrange: Choose a negative integer value for the email length.
  Act: Call the RandomEmail function with this negative integer.
  Assert: Validate whether the function returns any output and if it is handled properly (e.g., an empty string or an error).
Validation:
  Justify: Negative lengths don't correspond to valid use cases and should be handled in a predictable manner.
  Importance: Ensuring RandomEmail properly handles negative lengths prevents potential runtime errors and is part of defensive programming practices.

---

These scenarios cover the case of regular operation, a potential edge case, and an error handling scenario. To implement these tests, we would need to write test functions in Go using the `testing` package, making assertions on the results using `if` conditions or a testing assertion library.
*/

// ********RoostGPT********
package util

import (
	"strings"
	"testing"
)

// TestRandomEmailValidLength tests RandomEmail with a positive length
func TestRandomEmailValidLength(t *testing.T) {
	length := 10
	email := RandomEmail(length)
	expectedLength := length + len("@email.com")

	if len(email) != expectedLength {
		t.Errorf("expected email length of %d, got %d", expectedLength, len(email))
	}

	if !strings.HasSuffix(email, "@email.com") {
		t.Errorf("email should end with '@email.com', got %s", email)
	}

	if len(strings.TrimSuffix(email, "@email.com")) != length {
		t.Errorf("expected prefix length of %d, got %d", length, len(strings.TrimSuffix(email, "@email.com")))
	}
}

// TestRandomEmailZeroLength tests RandomEmail with a length of zero
func TestRandomEmailZeroLength(t *testing.T) {
	email := RandomEmail(0)

	if email != "@email.com" {
		t.Errorf("expected email to be '@email.com', got %s", email)
	}
}

// TestRandomEmailNegativeLength tests RandomEmail with a negative length
func TestRandomEmailNegativeLength(t *testing.T) {
	email := RandomEmail(-1)
	expected := "@email.com"

	// The behavior for negative length is not defined here
	// Assuming we expect the same behavior as zero length for the purpose of the test
	if email != expected {
		t.Errorf("expected email to be '%s', got %s", expected, email)
	}
}

