// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=RandomString_d7e3599ac4
ROOST_METHOD_SIG_HASH=RandomString_c6fe4ad19a

Scenario 1: Normal Case with a reasonable number
Details:
  Description: This test will check that the RandomString function is capable of generating a random string of the requested length under normal conditions. A reasonable number like 5 will be supplied as an input.
Execution:
  Arrange: No specific arrangement is required as RandomString does not depend on any external factors or data.
  Act: Invoke RandomString(5).
  Assert: Use Go testing facilities to verify that the string returned by RandomString has exactly 5 characters.
Validation:
  It is crucial that the function returns the correct number of characters. As the function being tested generates random strings, it isn't possible to check for a specific output string. Thus, the length of the string becomes the primary quality metric for the test. This basic test is a smoke test that checks if the function behaves as expected under normal circumstances.

Scenario 2: Edge Case of Zero 
Details:
  Description: This test will check how RandomString behaves when asked to generate a string of length zero. Although this isn't a particularly useful case, it's important to verify that edge cases like these are handled gracefully.
Execution:
  Arrange: No specific arrangement is required as RandomString does not depend on any external factors or data.
  Act: Invoke RandomString(0).
  Assert: Use Go testing facilities to verify that the string returned by RandomString is an empty string.
Validation:
  The function is expected to return an empty string when asked for a string of length 0. The logic behind this expected result is that a string of length zero has no characters. This test is essential to ensure that the function can handle edge cases gracefully.

Scenario 3: Edge Case of Large Number 
Details:
  Description: This test will check how the RandomString function behaves when asked to generate a very large string. This will serve as a stress test for the function ensuring it can handle high load as well.
Execution:
  Arrange: No specific arrangement is required as RandomString does not depend on any external factors or data.
  Act: Invoke RandomString(500000).
  Assert: Use Go testing facilities to verify that the string returned by RandomString has exactly 500000 characters.
Validation:
  It is essential that the function can handle generating large strings. This ability is important in scenarios where the program could be dealing with large inputs. 

Scenario 4: Negative number as input
Details:
  Description: This test will check how the RandomString function behaves when provided a negative number as input. The function is not expected to handle negative input and should throw an error. 
Execution:
  Arrange: No specific arrangement is required as RandomString does not depend on any external factors or data.
  Act: Invoke RandomString(-5).
  Assert: Use Go testing facilities to check if the function throws an error.
Validation:
  The function is expected to throw an error because it cannot generate a string with a negative length. Validating this ensures that the function correctly handles incorrect input and does not behave unexpectedly, which is crucial for the stability of the program.
*/

// ********RoostGPT********
package util_test

import (
	"math/rand"
	"strings"
	"testing"
	"time"
)

// create alphabet
var alphabet = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func TestRandomString(t *testing.T) {
	rand.Seed(time.Now().UnixNano())

	// defining a series of test cases
	testCases := []struct {
		name        string
		length      int
		expectError bool
	}{
		{"Normal Case", 5, false},
		{"Edge Case of Zero", 0, false},
		{"Edge Case of Large Number", 500000, false},
		{"Negative Number", -5, true},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			t.Log("Executing test scenario:", tc.name)

			result := RandomString(tc.length)
			
			if tc.expectError && result != "" {
				t.Errorf("Expected error, got nil")
				return
			}
			
			if !tc.expectError && result == "" {
				t.Errorf("Did not expect error, but got one")
				return
			}
			
			if tc.length != len(result) {
				t.Errorf("Expected length %d, got %d", tc.length, len(result))
			} else {
				t.Log("Success! The generated string length: ", len(result))
			}
			
			if len(result) < 0 {
				t.Errorf("Expected length to be non-negative, got %d", len(result))
			} else {
				t.Log("Success! The generated string length is non-negative: ", len(result))
			}
		})
	}
}

func RandomString(number int) string {
	if number < 0 {
		return ""
	}

	var sb strings.Builder
	k := len(alphabet)

	for i := 0; i < number; i++ {
		c := alphabet[rand.Intn(k)]
		sb.WriteRune(c)
	}
	return sb.String()
}
