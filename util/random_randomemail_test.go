// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calc using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=RandomEmail_1905439733
ROOST_METHOD_SIG_HASH=RandomEmail_7a04f189fd

Scenario 1: Positive test with appropriate input value

Details:
  Description: This will test the RandomEmail function with a valid positive number to check if it's correctly generating the Email.
Execution:
  Arrange: Nothing to arrange as we only need to pass a positive integer to generate a random string of that length.
  Act: Call the RandomEmail function with a positive integer value like 5.
  Assert: Validate that an email is returned matching the pattern "([a-zA-Z0-9_\-\.]+)@email.com".
Validation:
  We are expecting the format of returned string to match with the standard email format, hence we use regex pattern "(+@email.com)" to check if an email is returned. The importance of this test lies in validating standard usage of RandomEmail function to ensure it’s creating random email strings correctly.

Scenario 2: Zero length string

Details:
  Description: This test scenario is meant to check the behavior of RandomEmail function when zero is provided as argument.
Execution:
  Arrange: Nothing to arrange as we only need to pass zero to get an email with empty string before '@'.
  Act: Call the RandomEmail function with zero.
  Assert: Assert that the returned string is "@email.com".
Validation:
  We are expecting a string "@email.com" as there should be empty string before '@' since zero length string is requested. This test scenario is important because handling zero (edge case) correctly is important to ensure function’s robustness.

Scenario 3: Negative input value

Details:
  Description: This scenario is designed to observe how the RandomEmail function reacts when passed with a negative value.
Execution:
  Arrange: Nothing to arrange as only a negative input value needs to be passed.
  Act: Call the RandomEmail function passing a negative integer like -5.
  Assert: This might have different behaviors based on the implementation of RandomString function. If it's gracefully handling negative values, it might return "@email.com" (similar to zero case). If it's not treating negative values correctly, it might throw an error or panic. So the assertion should be prepared accordingly.
Validation:
  Either the function should handle negative values gracefully and return output similar to passing zero, or it should report an error. This test is important to ensure the stability of the application in case of unexpected input.  

Scenario 4: Large input value

Details:
  Description: This test scenario is to check if the RandomEmail function can handle large input values.
Execution:
  Arrange: There is nothing to arrange as we only need to pass a positive large integer value.
  Act: Call the RandomEmail function with a large number like 100000.
  Assert: Probably, Go has enough memory to handle a string of this length, so we equality-assert the length of the returned email (without "@email.com") to be equal to the applied number.
Validation:
  The test is designed to ensure RandomEmail function can handle large inputs correctly and is not memory-bound for most typical sizes of email strings. This maintains the function's usability across a range of scenarios.
*/

// ********RoostGPT********
package util

import (
	"fmt"
	"testing"
	"regexp"
	"math/rand"
	"time"
)

// TestRandomEmail
// - Test cases are created based on the Scenarios provided
// - TODO: This test assumes that the function RandomString is correctly implemented. If not, the tests might fail even when the RandomEmail function is correctly implemented.
func TestRandomEmail(t *testing.T) {
	// Arrange
	cases := []struct {
		name          string
		input         int
		expectedRegex string
		expectedError bool
	}{
		{
			name:          "Positive input value",
			input:         5,
			expectedRegex: `^[a-zA-Z0-9]{5}@email.com`,
		},
		{
			name:          "Zero length string",
			input:         0,
			expectedRegex: `^@email.com`,
		},
		{
			name:          "Negative input value",
			input:         -5,
			expectedRegex: `^@email.com`, // Expect same result as zero length string
			expectedError: true,            // TODO: Update this flag to true if you expect an error when input < 0
		},
		{
			name:          "Large input value",
			input:         100000,
			expectedRegex: fmt.Sprintf(`^[a-zA-Z0-9]{%d}@email.com`, 100000),
		},
	}

	rand.Seed(time.Now().UnixNano())

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			// Act
			result := RandomEmail(c.input)

			// Assert
			if c.expectedError && c.input < 0 {
				t.Fatalf("Expected an error but got none")
			} else if !c.expectedError && c.input < 0 {
				t.Fatalf("Did not expect an error but got one: %v", c.input)
			}

			matched, err := regexp.Match(c.expectedRegex, []byte(result))
			if err != nil {
				t.Fatalf("Could not execute regex test: %v", err)
			}

			if !matched {
				t.Errorf("Expected to match regex but it did not: input(%d), email(%s)", c.input, result)
			}
		})
	}
}
