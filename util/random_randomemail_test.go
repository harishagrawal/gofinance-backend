// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=RandomEmail_1905439733
ROOST_METHOD_SIG_HASH=RandomEmail_7a04f189fd

Scenario 1: Generate valid random email for the number greater than zero

Details:
Description: This test checks if the function `RandomEmail` can generate a valid email which contains the requested number of random characters before the "@" sign.
Execution:
Arrange: No preparation needed.
Act: Invoke `RandomEmail` with a single positive number as a parameter.
Assert: Check if the result is valid and meets our expectations - contains "@" sign and random string length is exactly as specified in the parameter.
Validation:
The test is important because it checks the regular work of our function. We choose simple validation just to check if the number of characters before the "@" is the same as parameter.

Scenario 2: Generate valid random email for the zero number

Details:
Description: The test checks if the function `RandomEmail` can handle zero as a parameter and generate a valid email "random" string with zero characters before the "@".
Execution:
Arrange: No preparation needed.
Act: Invoke `RandomEmail` with zero as a parameter.
Assert: Check if the result is valid - it should contain nothing before "@".
Validation:
The test is important to check the edge case when the number parameter equals zero. It's important because it's a limit situation for our function.

Scenario 3: Generate valid random email for a very large number

Details:
Description: The test is designed to check if the function `RandomEmail` can handle a very large number as a parameter and generate a valid email "random" string of length equal to that big number.
Execution:
Arrange: No preparation needed.
Act: Invoke `RandomEmail` with a very large number as a parameter.
Assert: Check if the result is valid - it should contain a long string before "@".
Validation:
The test is important because it checks how our function behaves with extremely big inputs. This might be important due to memory constraints or for performance consideration.

Scenario 4: Generate valid random email for negative numbers

Details:
Description: The test checks if the function `RandomEmail` can handle negative numbers. It's unclear how this function will behave in such a case (it might reject such inputs or treat them as positive), so it's important to clarify this behavior.
Execution:
Arrange: No preparation needed.
Act: Invoke `RandomEmail` with a negative number as a parameter.
Assert: Check how the function behaves - does it return any valid value or does it cause a run-time error?
Validation:
The test is important because it's an edge case for our function. Handling negative values can be problematic and it's good to be sure how our function behaves in this situation.
*/

// ********RoostGPT********
// Begin Test Code
package util

import (
	"testing"
	"strings"
)

func TestRandomEmail(t *testing.T) {
	tests := []struct {
		input    int
		expected string
		err      bool
	}{
		{5, "@email.com", false},                  // Scenario 1: Generate valid random email for the number greater than zero
		{0, "@email.com", true},                   // Scenario 2: Generate valid random email for the zero number
		{10000, "@email.com", false},              // Scenario 3: Generate valid random email for a very large number
		{-5, "Invalid number", true},              // Scenario 4: Generate valid random email for negative numbers
	}

	for _, test := range tests {
		result := RandomEmail(test.input)
		if test.err && result != test.expected {
			t.Errorf("RandomEmail(%d) failed, expected %v, got %v", test.input, test.expected, result)
		} else if !test.err && !strings.Contains(result, test.expected) {
			t.Errorf("RandomEmail(%d) failed, expected Domain %v, got %v", test.input, test.expected, result)
		} else {
			t.Logf("RandomEmail(%d) success, expected %v, got %v", test.input, test.expected, result)
		}
	}
}

// End Test Code
